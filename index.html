<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set Operations Calculator - Discrete Math</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .particles { position: fixed; inset: 0; overflow: hidden; z-index: 0; pointer-events: none; }
        .particle { position: absolute; border-radius: 50%; background: radial-gradient(circle, hsl(180,100%,80%) 0%, hsl(180,100%,80%) 10%, hsla(180,100%,80%,0) 70%); mix-blend-mode: screen; animation: float 15s infinite linear; }
        @keyframes float { from { transform: translateY(110vh) scale(0.4); opacity: 0; } 10% { opacity: 1; } 90% { opacity: 1; } to { transform: translateY(-20vh) scale(2.2); opacity: 0; } }
    </style>
</head>
<body>
    <div class="particles">
        <div class="particle" style="left:5%;width:8px;height:8px;animation-delay:0s;animation-duration:12s;"></div>
        <div class="particle" style="left:15%;width:4px;height:4px;animation-delay:2s;animation-duration:14s;"></div>
        <div class="particle" style="left:25%;width:6px;height:6px;animation-delay:4s;animation-duration:11s;"></div>
        <div class="particle" style="left:35%;width:3px;height:3px;animation-delay:1s;animation-duration:15s;"></div>
        <div class="particle" style="left:45%;width:7px;height:7px;animation-delay:3s;animation-duration:13s;"></div>
        <div class="particle" style="left:55%;width:5px;height:5px;animation-delay:5s;animation-duration:10s;"></div>
        <div class="particle" style="left:65%;width:4px;height:4px;animation-delay:2.5s;animation-duration:16s;"></div>
        <div class="particle" style="left:75%;width:6px;height:6px;animation-delay:4.5s;animation-duration:12s;"></div>
        <div class="particle" style="left:85%;width:3px;height:3px;animation-delay:1.5s;animation-duration:14s;"></div>
        <div class="particle" style="left:95%;width:5px;height:5px;animation-delay:3.5s;animation-duration:11s;"></div>
        <div class="particle" style="left:10%;width:4px;height:4px;animation-delay:6s;animation-duration:13s;"></div>
        <div class="particle" style="left:30%;width:6px;height:6px;animation-delay:7s;animation-duration:15s;"></div>
        <div class="particle" style="left:50%;width:3px;height:3px;animation-delay:8s;animation-duration:12s;"></div>
        <div class="particle" style="left:70%;width:5px;height:5px;animation-delay:9s;animation-duration:14s;"></div>
        <div class="particle" style="left:90%;width:4px;height:4px;animation-delay:10s;animation-duration:11s;"></div>
    </div>

    <div class="container" style="position:relative;z-index:1;">
        <div class="card">
            <h1>Set <span class="math-symbol">Operations</span></h1>
            <p class="subtitle">Discrete Mathematics Calculator</p>
            
            <div class="num-sets-section">
                <label>Universal Set (U):</label>
                <input type="text" id="universalSet" placeholder="e.g., a,b,c,d,e" style="flex:1;min-width:150px;" oninput="calculateResult()">
            </div>
            
            <div class="num-sets-section">
                <label>Number of Sets:</label>
                <input type="number" id="numSets" value="2" min="2" max="6">
                <span class="hint-text">(2-6 sets)</span>
            </div>
            
            <div class="sets-container" id="setsContainer"></div>
            
            <div class="expression-builder">
                <h3>Build Expression</h3>
                <div class="expression-row" id="expressionRow"></div>
                <div class="expression-display" id="expressionDisplay">
                    <span class="sets">Select sets and operations above</span>
                </div>
                <div style="margin-top:10px;text-align:center;">
                    <button class="clear-btn" onclick="clearExpression()">Clear</button>
                </div>
            </div>
            
            <div class="result-section">
                <h3>Result</h3>
                <div class="result-value" id="result">∅</div>
            </div>
        </div>
    </div>

    <script>
        let numSets = 2;
        let expression = [];
        const setLetters = ['A', 'B', 'C', 'D', 'E', 'F'];
        let parenResults = {}; // Store results from parentheses
        let parenCounter = 0;

        function onNumSetsChange() {
            const val = Math.min(6, Math.max(2, parseInt(document.getElementById('numSets').value) || 2));
            if (val !== numSets) {
                numSets = val;
                document.getElementById('numSets').value = numSets;
                updateSetsContainer();
                buildExpressionUI();
                clearExpression();
            }
        }
        
        document.getElementById('numSets').addEventListener('change', onNumSetsChange);
        document.getElementById('numSets').addEventListener('input', onNumSetsChange);

        function updateSetsContainer() {
            const container = document.getElementById('setsContainer');
            let html = '';
            for (let i = 0; i < numSets; i++) {
                const letter = setLetters[i];
                html += '<div class="set-input-card"><label>Set <span>' + letter + '</span></label><input type="text" id="set' + letter + '" placeholder="e.g., a,b,c,d" oninput="calculateResult()"><p class="hint">Enter elements separated by commas</p></div>';
            }
            container.innerHTML = html;
        }

        function parseSetInput(input) {
            if (!input || !input.trim()) return [];
            // Split by comma and trim whitespace from each element
            return input.split(',').map(x => x.trim()).filter(x => x !== '');
        }

        function getUniversalSet() {
            const input = document.getElementById('universalSet');
            return new Set(parseSetInput(input.value));
        }

        function getSetValue(letter) {
            const input = document.getElementById('set' + letter);
            if (!input || !input.value.trim()) return new Set();
            const universalSet = getUniversalSet();
            const elements = parseSetInput(input.value);
            
            // If U is defined, only keep elements that are in U
            if (universalSet.size > 0) {
                return new Set(elements.filter(e => universalSet.has(e)));
            }
            // If U is not defined, keep all entered elements
            return new Set(elements);
        }

        function setToArray(set) {
            return Array.from(set).sort((a, b) => {
                // Parse as numbers for initial comparison
                const numA = parseFloat(a);
                const numB = parseFloat(b);
                const aIsNum = !isNaN(numA) && a.trim() === String(numA);
                const bIsNum = !isNaN(numB) && b.trim() === String(numB);
                
                // If both are clean numbers, sort numerically
                if (aIsNum && bIsNum) {
                    return numA - numB;
                }
                // Otherwise use string comparison for consistency
                return String(a).localeCompare(String(b));
            });
        }

        function formatResult(set) {
            if (set.size === 0) return '∅';
            return '{ ' + setToArray(set).join(', ') + ' }';
        }

        function calculateResult() {
            validateAllSets();
            
            const resultEl = document.getElementById('result');
            if (expression.length === 0) {
                resultEl.innerHTML = '∅';
                resultEl.className = 'result-value empty-set';
                return;
            }
            try {
                let result = evaluateExpression(expression);
                const formatted = formatResult(result);
                resultEl.textContent = formatted;
                
                if (result.size === 0) {
                    resultEl.className = 'result-value empty-set';
                } else {
                    resultEl.className = 'result-value';
                }
            } catch (e) {
                resultEl.innerHTML = '∅';
                resultEl.className = 'result-value empty-set';
            }
        }

        function evaluateExpression(expr) {
            if (expr.length === 0) return new Set();
            
            // Validate parentheses matching
            let parenDepth = 0;
            for (let item of expr) {
                if (item.type === 'paren' && item.value === '(') parenDepth++;
                else if (item.type === 'paren' && item.value === ')') {
                    parenDepth--;
                    if (parenDepth < 0) return new Set(); // Unmatched closing paren
                }
            }
            if (parenDepth !== 0) return new Set(); // Unmatched opening paren
            
            // First pass: handle parentheses (innermost first)
            let processed = processParentheses(expr);
            
            // Second pass: handle complement operators (highest precedence)
            processed = processComplements(processed);
            
            // Third pass: evaluate the main expression (∩ and ∪ left-to-right)
            let result = null;
            let pendingOp = null;
            
            for (let i = 0; i < processed.length; i++) {
                const item = processed[i];
                
                if (item.type === 'set') {
                    let set;
                    // Check if this is a parenthesis result or complement result
                    if (item.value.startsWith('__paren_') || item.value.startsWith('__comp_')) {
                        set = parenResults[item.value] || new Set();
                    } else {
                        set = getSetValue(item.value);
                    }
                    
                    if (result === null) {
                        result = set;
                    } else if (pendingOp === '∩') {
                        result = intersection(result, set);
                    } else if (pendingOp === '∪') {
                        result = union(result, set);
                    }
                    pendingOp = null;
                } else if (item.type === 'op') {
                    pendingOp = item.value;
                }
            }
            
            return result || new Set();
        }
        
        function processComplements(expr) {
            let result = [];
            let i = 0;
            
            while (i < expr.length) {
                const item = expr[i];
                
                // If we find a complement operator, apply it to the preceding set
                if (item.type === 'op' && item.value === "'") {
                    if (result.length > 0) {
                        const lastItem = result.pop();
                        
                        // Get the set to complement (already computed or stored)
                        let setToComplement;
                        if (lastItem.value.startsWith('__paren_') || lastItem.value.startsWith('__comp_')) {
                            setToComplement = parenResults[lastItem.value] || new Set();
                        } else {
                            // Get and apply U filtering here
                            setToComplement = getSetValue(lastItem.value);
                        }
                        
                        // Apply complement
                        const complemented = complement(setToComplement);
                        const resultKey = '__comp_' + (parenCounter++);
                        parenResults[resultKey] = complemented;
                        
                        result.push({ type: 'set', value: resultKey });
                    }
                } else {
                    result.push(item);
                }
                i++;
            }
            
            return result;
        }
        
        function processParentheses(expr) {
            let depth = 0;
            let openAt = -1;
            
            // Find innermost parentheses and evaluate them
            for (let i = 0; i < expr.length; i++) {
                const item = expr[i];
                
                if (item.type === 'paren' && item.value === '(') {
                    if (depth === 0) openAt = i;
                    depth++;
                } else if (item.type === 'paren' && item.value === ')') {
                    depth--;
                    if (depth === 0 && openAt !== -1) {
                        // Found complete parentheses group
                        const innerExpr = expr.slice(openAt + 1, i);
                        const groupResult = evaluateExpression(innerExpr);
                        
                        // Store result with unique key
                        const resultKey = '__paren_' + (parenCounter++);
                        parenResults[resultKey] = groupResult;
                        
                        // Replace parentheses and contents with single set item
                        expr = expr.slice(0, openAt).concat(
                            [{ type: 'set', value: resultKey }],
                            expr.slice(i + 1)
                        );
                        
                        // Recursively process remaining parentheses
                        return processParentheses(expr);
                    }
                }
            }
            
            return expr;
        }

        function intersection(setA, setB) {
            const r = new Set();
            setA.forEach(e => {
                if (setB.has(e)) r.add(e);
            });
            return r;
        }

        function union(setA, setB) {
            const r = new Set(setA);
            setB.forEach(e => r.add(e));
            return r;
        }

        function complement(set) {
            const universalInput = document.getElementById('universalSet');
            const all = new Set();
            if (universalInput && universalInput.value.trim()) {
                const elements = parseSetInput(universalInput.value);
                elements.forEach(e => all.add(e));
            } else {
                // If U not defined, use unfiltered elements from all sets
                for (let i = 0; i < numSets; i++) {
                    const input = document.getElementById('set' + setLetters[i]);
                    if (input && input.value.trim()) {
                        parseSetInput(input.value).forEach(e => all.add(e));
                    }
                }
            }
            const r = new Set();
            all.forEach(e => {
                if (!set.has(e)) r.add(e);
            });
            return r;
        }

        function validateSetInput(letter) {
            const input = document.getElementById('set' + letter);
            if (!input) return;
            
            const universalSet = getUniversalSet();
            if (universalSet.size === 0) {
                input.classList.remove('invalid');
                return;
            }
            
            const elements = parseSetInput(input.value);
            const hasInvalidElement = elements.some(e => !universalSet.has(e));
            
            if (hasInvalidElement) {
                input.classList.add('invalid');
            } else {
                input.classList.remove('invalid');
            }
        }

        function validateAllSets() {
            for (let i = 0; i < numSets; i++) {
                validateSetInput(setLetters[i]);
            }
        }

        function addSetToExpression(letter) {
            const last = expression[expression.length - 1];
            if (last && last.type === 'set') addOpToExpression('∩');
            expression.push({ type: 'set', value: letter });
            updateExpressionDisplay();
            calculateResult();
        }

        function addOpToExpression(op) {
            if (expression.length === 0) return;
            const last = expression[expression.length - 1];
            // Allow ∩/∪ after complement ('), prevent other ops after ops/open paren
            if ((last.type === 'op' && last.value !== "'") || last.type === 'openParen') return;
            expression.push({ type: 'op', value: op });
            updateExpressionDisplay();
            calculateResult();
        }

        function addParenToExpression(paren) {
            expression.push({ type: 'paren', value: paren });
            updateExpressionDisplay();
            calculateResult();
        }

        function updateExpressionDisplay() {
            const display = document.getElementById('expressionDisplay');
            if (expression.length === 0) {
                display.innerHTML = '<span class="sets">Select sets and operations above</span>';
                return;
            }
            let html = '';
            expression.forEach(item => {
                if (item.type === 'set') html += '<span class="sets">' + item.value + '</span> ';
                else if (item.type === 'op') html += item.value + ' ';
                else if (item.type === 'paren') html += item.value + ' ';
            });
            display.innerHTML = html;
        }

        function clearExpression() { 
            expression = []; 
            parenResults = {};
            parenCounter = 0;
            updateExpressionDisplay(); 
            calculateResult();
        }

        function buildExpressionUI() {
            const row = document.getElementById('expressionRow');
            let html = '';
            for (let i = 0; i < numSets; i++) html += '<button class="op-btn" onclick="addSetToExpression(\'' + setLetters[i] + '\')">' + setLetters[i] + '</button>';
            html += '<button class="op-btn" onclick="addParenToExpression(\'(\')">(' + '</button>';
            html += '<button class="op-btn" onclick="addParenToExpression(\')\')">)</button>';
            html += '<button class="op-btn" onclick="addOpToExpression(\'∩\')">∩</button>';
            html += '<button class="op-btn" onclick="addOpToExpression(\'∪\')">∪</button>';
            html += '<button class="op-btn" onclick="addOpToExpression(\'\\\'\')">' + "'" + '</button>';
            row.innerHTML = html;
        }

        document.addEventListener('DOMContentLoaded', function() { 
            updateSetsContainer(); 
            buildExpressionUI();
            calculateResult(); 
        });
    </script>
</body>
</html>
